// 1.Binary search
#include<iostream>
using namespace std;
void search(int l,int h,int key,int arr[])
{
    if(l>h)
    {
        cout<< "NO OCCURRENCES";
    }
    else
    {
        int mid=(l+h)/2;
        if(key==arr[mid])
        {
            cout<<mid;
        }
        else if(key<arr[mid])
        {
            search(l,mid-1,key,arr);
        }
        else
        {
            search(mid+1,h,key,arr);
        }
    }
}
int main()
{
    int a,key;cin>>a;
    int arr[a];
    for(int i=0;i<a;i++)
        cin>>arr[i];
        
    cin>>key;
    for(int i=0;i<a;i++){
        for(int j=0;j<a;j++){
            if(arr[i]<arr[j]){
                int temp=arr[i];
                arr[i]=arr[j];
                arr[j]=temp;
            }
        }
    }
    search(0,a-1,key,arr);
    
}

//2.Linear search
#include<iostream>
using namespace std;
void print(int arr[],int a,int ele)
{
    for(int i=0;i<a;i++)
    {
        if(arr[i]==ele)
        {    cout<<"Yes";
            return;
        }
    }
    cout<<"No";
    
}
int main()
{
    int a;
    cin>>a;
    int arr[a];
    for(int i=0;i<a;i++)
        cin>>arr[i];
        
    int ele;
    cin>>ele;
    print(arr,a,ele);
}

//3.bubbleSort 
#include<iostream>
using namespace std;
void bubbleSort(int arr[],int a)
{
    for(int i=0;i<a-1;i++)
    {
        for(int j=0;j<a-i-1;j++)
        {
            if(arr[j]>arr[j+1])
            {
                int temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
    }
    for(int i=0;i<a;i++)
    {
        cout<<arr[i]<<" ";
    }
}

int main()
{
    int n;cin>>n;
    int arr[n];
    for(int i=0;i<n;i++)
        cin>>arr[i];
        
    bubbleSort(arr,n);
}

//4. insertion sort
#include<iostream>
using namespace std;
void insertion(int arr[],int a)
{
    int k;
    for (int i=1;i<a;i++) 
    {
        k=arr[i];
        int j=i-1;
        while(j>=0 && arr[j]>k)
        {
            arr[j+1]=arr[j];
            j=j-1;
        }
        arr[j+1]=k;
    }
    for(int i=0;i<a;i++)
    {
        cout<< arr[i] <<" ";
    }
}
int main()
{
    int a;cin>>a;
    int arr[a];
    for(int i=0;i<a;i++)
        cin>>arr[i];
        
    insertion(arr,a);
}

// 5.selection sort
#include<iostream>
using namespace std;
struct data
{
    int date;
    int month;
    int year;
};

int main()
{
    int n;
    cin>>n;
    struct data arr[n];
    for(int i=0;i<n;i++)
    {
        cin>>arr[i].date;
        cin>>arr[i].month;
        cin>>arr[i].year;
    }
    for(int i=0;i<n-1;i++)
    {
        for(int j=i+1;j<n;j++)
        {
            if(arr[i].year>arr[j].year)
            {
                struct data temp=arr[i];
                arr[i]=arr[j];
                arr[j]=temp;
            }
            else if(arr[i].year==arr[j].year && arr[i].month>arr[j].month)
            {
                struct data temp=arr[i];
                arr[i]=arr[j];
                arr[j]=temp;
            }
            else if(arr[i].year==arr[j].year && arr[i].month==arr[j].month && arr[i].date>arr[j].date)
            {
                struct data temp=arr[i];
                arr[i]=arr[j];
                arr[j]=temp;
            }
            
        }
    }
    for(int i=0;i<n;i++)
    {
        cout<<arr[i].date<<" "<<arr[i].month<<" "<<arr[i].year<<endl;
    }
        
    
}

//6. max heap sort
#include<iostream>
using namespace std;
void maxHeapify(int arr[],int a,int i)
{
    int large=i;
    int l=2*i+1;
    int r=2*i+2;
    if(l<a &&arr[l]>arr[large])
        large=l;
    if(r<a &&arr[r]>arr[large])
        large=r;
    if(large!=i)
    {
        swap(arr[i],arr[large]);
        maxHeapify(arr,a,large);
    }
}
void maxheap(int arr[],int n)
{
    for(int i=n/2-1;i>=0;i--)
        maxHeapify(arr,n,i);
    for(int i=n-1;i>0;i--)
    {
        swap(arr[0],arr[i]);
        maxHeapify(arr,i,0);
    }
    
}


int main() 
{
    int a;
    cin>>a;
    int arr[a];
    for(int i=0;i<a;i++) cin>>arr[i];
    maxheap(arr,a);
    for(int i=0;i<a;i++) cout<<arr[i]<<" ";
    
}

//7. quick sort
#include<iostream>
using namespace std;
int swap(int arr[],int i,int j)
{
    int temp=arr[i];
    arr[i]=arr[j];
    arr[j]=temp;
}
int part(int arr[],int l,int h)
{
    int pivot=arr[h];
    int i=l-1;
    for(int j=l;j<=h;j++)
    {
        if(arr[j]<pivot)
        {
            i++;
            swap(arr,i,j);
        }
    }
    swap(arr,i+1,h);
    return (i+1);
}
void quicksort(int arr[],int l,int h)
{
    if(l<h)
    {
        int pivindex=part(arr,l,h);
        quicksort(arr,l,pivindex-1);
        quicksort(arr,pivindex+1,h);
    }
}
int main()
{
    int a;cin>>a;
    int arr[a];
    for(int i=0;i<a;i++) cin>>arr[i];
    quicksort(arr,0,a-1);
    for(int i=0;i<a;i++) cout<<arr[i]<<" ";
    
    
}

//8. Merge sort
#include <iostream>
using namespace std;
void merge(int arr[], int l, int m, int r) 
{
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;     
    int L[n1], R[n2];
    
    for (i = 0; i < n1; i++) L[i] = arr[l + i];
    for (j = 0; j < n2; j++) R[j] = arr[m + 1 + j];
    i = 0;
    j = 0;
    k = l;
    
    while (i < n1 && j < n2) 
    {
        if (L[i] <= R[j]) 
        {
            arr[k] = L[i];
            i++;
        } else 
        {
            arr[k] = R[j];
            j++;
        }
        k++;
    }
    
    while (i < n1) 
    {
        arr[k] = L[i];
        i++;
        k++;
    }
    
    while (j < n2) 
    {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int l, int r) 
{
    if (l < r) 
    {
        int m = l + (r - l) / 2; 
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

void PrintArray(int A[], int size) 
{
    for (int i = 0; i < size; i++)
        cout << A[i] << " ";
    cout <<endl;
}
int main() 
{
    int n;
    cin >> n;
    int arr[n];
    for (int i = 0; i < n; i++) cin >> arr[i];
   
    mergeSort(arr, 0, n - 1);
    PrintArray(arr, n);
}

//9. Activity selection
#include<iostream>
using namespace std;
struct Match
{
    string name;
    int stime;
    int ftime;
};
int main()
{
    int a;cin>>a;
    struct Match arr[a];
    for(int i=0;i<a;i++)
    {
        cin>>arr[i].name>>arr[i].stime>>arr[i].ftime;
    }
    for(int i=0;i<a-1;i++)
    {
        for(int j=0;j<a-i-1;j++)
        {
            if(arr[j].ftime>arr[j+1].ftime)
            {
                struct Match temp=arr[j];
                arr[j]=arr[j+1];
                arr[j+1]=temp;
            }
        }
    }
    
    cout<<"Selected Activities are:"<<endl;
    cout<<arr[0].name<<" ";
    
    int k=0;
    for(int i=0;i<a;i++)
    {
        if(arr[i].stime>=arr[k].ftime)
        {
            cout<<arr[i].name;
            k=i;
        }
    }
    
    
}

//10.Knapsack problem
#include<iostream>
#include<iomanip>
using namespace std;
struct knap
{
    float w;
    float p;
    float pw;
};
int main()
{
    int a;
    cin>>a;
    knap item[a];
    for(int i=0;i<a;i++)
    {
        cin>>item[i].w>>item[i].p;
        item[i].pw=item[i].p/item[i].w;
    }
    
    for(int i=0;i<a;i++)
    {
        for(int j=0;j<a;j++)
        {
            if(item[i].pw>item[j].pw)
            {
                knap temp=item[i];
                item[i]=item[j];
                item[j]=temp;
            }
        }
    }
    float tp=0,wg=0,mw;
    cin>>mw;
    int i=0;
    for(i;i<a;i++)
    {
        wg+=item[i].w;
        if(wg>mw)
        {
            wg-=item[i].w;
            break;
        }
        else
        {
            tp+=item[i].p;
        }
    }
    float q=((mw-wg)/item[i].w);
    cout<<"Maximum profit is:- ";
    cout<<fixed<<setprecision(2)<<(q*item[i].p)+tp;
}

//11. Naive algorithm
#include<iostream>
using namespace std;
void naive(string str1,string str2)
{
    int m=str1.length();
    int p=str2.length();
    int i,j;
    for(i=0;i<m-p;i++)
    {
        for(j=0;j<p;j++)
        {
            if(str1[i+j]!=str2[j])
            {
                break;
            }
        }
        if(j==p)
            cout<<"Found at "<<i;
            break;
    }
    if(j!=p)
        cout<<"Not Found";
}
int main()
{
    string s,pat;
    cin>>s>>pat;
    naive(s,pat);
}

//12. KMP Algorithm
#include<iostream>
#include<vector>
using namespace std;
void compute(string pat,int M,vector<int>& lps)
{
    int len=0;
    int i=1;
    lps[0]=0;
    while(i<M)
    {
        if(pat[i]==pat[len])
        {
            len++;
            lps[i]=len;
            i++;
            
        }
        else
        {
            if(len!=0)
                len=lps[len-1];
            else
            {
                lps[i]=len;
                i++;
            }
        }
    }
}
void kmpsearch(string pat,string txt)
{
    int M=pat.length();
    int N=txt.length();
    
    vector<int>lps(M);
    int j=0;
    compute(pat,M,lps);
    
    bool found=false;
    int i=0;
    while(N-i >= M-j)
    {
        if(pat[j]==txt[i])
        {
            j++;i++;
        }
        if(j==M)
        {
            found = true;
            cout<<"Found at "<<(i-j)<<endl;
            j=lps[j-1];
        }
        else if(i<N and pat[j]!=txt[i])
        {
             if(j!=0)
                j=lps[j-1];
            else
                i=i+1;
        }
    }
    if(not found)
    {
        cout<<"Not Found"<<endl;
    }
}
int main()
{
    string str,pat;
    cin>>str>>pat;
    kmpsearch(pat,str);
}

//13.Subset Sum Problem:
#include <iostream>
using namespace std;
int count = 0;
void subset (int arr[], int n, int sum, int start_index, int target_sum)
{
    if (target_sum == sum) 
    {
        count ++;
        if (start_index < n)
        {
            subset (arr, n, sum - arr[start_index - 1], start_index, target_sum);
        }
    } 
    else 
    {
        for (int i = start_index; i < n; i++) 
        {
            subset (arr, n, sum + arr[i], i + 1, target_sum);
        }
    }
}
int main() 
{
    int n, sum;
    cin >> n;
    int arr[n];
    for (int i = 0; i < n; i++) 
        cin >> arr[i];
        
    cin >> sum;
    subset (arr, n, 0, 0, sum);
    cout << count << endl;
}

//14. Rat in a Maze:
#include <iostream>
using namespace std;
#define max 10
int n;
void print (int ans[max][max])
{
    for (int i = 0 ; i < n ; i ++)
    {
        for (int j = 0 ; j < n ; j ++)
        {
            cout << ans[i][j] << " ";
        }
        cout << endl;
    }
}
bool safe (int maze[max][max] , int x , int y)
{
    return ( x >= 0 and x < n and y >= 0 and y < n and maze[x][y] == 1);
}
bool solving (int maze[max][max] , int x , int y , int ans[max][max])
{
    if ( x == n - 1 and y == n - 1 and maze[x][y] == 1)
    {
        ans[x][y] = 1;
        return true;
    }
    if ( safe (maze , x , y))
    {
        if(ans[x][y] == 1)
        {
            return false;
        }
        ans[x][y] = 1;
        if (( solving (maze , x + 1 , y , ans)) or ( solving (maze , x , y + 1 , ans)))
        {
            return true;
        }
        ans[x][y] = 0;
        return false;
        
    }
    return false;
}
bool solveMaze (int maze[max][max])
{
    int ans[max][max] = {0};
    if ( not solving (maze , 0 , 0 , ans))
    {
        cout << "Solution doesn't exist" << endl;
        return false;
    }
    print (ans);
    return true;
}
int main()
{
    // int n;
    cin >> n;
    int maze[max][max];
    for (int i = 0 ; i < n ; i ++)
    {
        for (int j = 0 ; j < n ; j ++)
        {
            cin >> maze[i][j];
        }
    }
    solveMaze (maze);
    
}

//15. Longest Common Subsequence
#include <iostream>
using namespace std;
int Lcs (string x , string y , int m , int n)
{
    int l[m+1][n+1];
    for (int i = 0 ; i <= m ; i++)
    {
        for (int j = 0 ; j <= n ; j++)
        {
            if (i == 0 or j == 0)
                l[i][j] = 0;
            else if (x[i-1] == y[j-1])
                l[i][j] = l[i-1][j-1] + 1;
            else
                l[i][j] = max(l[i-1][j] , l[i][j-1]);
        }
    }
    return l[m][n];
}
int max (int a ,int b)
{
    return (a > b) ? a : b;
}
int main()
{
    string a , b;
    cin >> a >> b;
    cout << Lcs (a , b , a.length() , b.length());
}

//16. Levenshtein Distance
#include <iostream>
using namespace std;
int LD (string x , string y , int m , int n)
{
    int ld[m+1][n+1];
    for (int i = 0 ; i <= m ; i++)
    {
        for (int j = 0 ; j <= n ; j++)
        {
            if (i == 0)
                ld[i][j] = j;
            else if(j == 0)
                ld[i][j] = i;
            else if (x[i-1] == y[j-1])
                ld[i][j] = ld[i-1][j-1];
            else
                ld[i][j] = min ( min (ld[i-1][j-1] , ld[i-1][j] ), ld[i][j-1]) + 1;
        }
    }
    return ld[m][n];
}
int min(int a , int b)
{
    return (a < b) ? a : b ;
}
int main()
{
    string a , b;
    cin >> a >> b;
    cout << LD (a , b , a.length() , b.length());
}

//17. Segment Tree Range Minimum Query
#include <iostream>
#include <climits>
#include <cmath>
using namespace std;

void build(int arr[], int tree[], int start, int end, int treeNode)
{
    if (start == end) 
    {
        tree[treeNode] = arr[start];
        return;
    }

    int mid = (start + end) / 2;
    build(arr, tree, start, mid, 2 * treeNode + 1);
    build(arr, tree, mid + 1, end, 2 * treeNode + 2);

    tree[treeNode] = min(tree[2 * treeNode+1], tree[2 * treeNode + 2]);
}

int query(int tree[], int start, int end, int treeNode, int left, int right) 
{
    if (left > end or right < start)
        return INT_MAX;
    if (left <= start and right >= end)
        return tree[treeNode]; 

    int mid = (start + end) / 2;
    int leftt = query(tree, start, mid, 2 * treeNode + 1, left, right);
    int rightt = query(tree, mid + 1, end, 2 * treeNode + 2, left, right);

    return min(leftt,rightt);
}


int main()
{
    int n; 
    cin >> n;
    int arr[n]; 
    for (int i = 0; i < n; i++) cin >> arr[i];
    
    int left, right; 
    cin >> left >> right;
    int treeSize = 100;
    
    int tree[treeSize]; 

    build(arr, tree, 0, n - 1, 0);   
    cout << "Minimum of values in range [" << left << ", " << right << "] is = " ;
    cout <<  query(tree, 0, n - 1, 0, left, right)<< endl;

}

//18. Range Minimum Query Using Sparse Table
#include <iostream>
#include <vector>
#include <cmath>
using namespace std;
const int MAXN = 100005;
const int K = 25;
int st[MAXN][K + 1];

void buildSparseTable(vector<int>& arr, int n) 
{
    for (int i = 0; i < n; i++) 
    {
        st[i][0] = arr[i];
    }

    for (int j = 1; j <= K; j++)
    {
        for (int i = 0; i + (1 << j) <= n; i++) 
        {
            st[i][j] = min(st[i][j - 1], st[i + (1 << (j - 1))][j - 1]);
        }
    }
}
int query(int l, int r) 
{
    int j = log2(r - l + 1);
    return min(st[l][j], st[r - (1 << j) + 1][j]);
}

int main()
{
    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) cin >> arr[i];

    buildSparseTable(arr, n);

    int l, r;
    cin >> l >> r;

    int result = query(l, r);
    cout << result << endl;

}

//19.Floyd Warshall Algorithm
#include<iostream>
using namespace std;
int INF= 99999;
int V;
void Floyd(int **graph)
{
	int dist[V][V] , i , j , k;
	for(i = 0; i < V; i++) 
	{		
			for(j = 0; j < V; j++) 
			{
				dist[i][j] = graph[i][j];
			}
	}
	
	for (k = 0; k < V; k++) 
	{
		for (i = 0; i < V; i++) 
		{		
			for (j = 0; j < V; j++) 
			{
				if (dist[i][j] > dist[i][k] + dist[k][j])
					dist[i][j] = dist[i][k] + dist[k][j];
			}
		}
	}
    cout<<"Shortest path matrix"<<endl;
	for (i = 0; i < V; i++) 
	{
			for (j = 0; j < V; j++) 
			{
				if (dist[i][j] == INF)
					cout << "INF" << " ";
				else
					cout << dist[i][j] << " ";
			}
			cout << endl;
	}
}
int main()
{
	int E , source , destn , value;
	cin >> V >> E;
	int **graph = new int*[V]; 
	for (int i = 0 ; i < V ; i++)
	{
        graph[i] = new int[V];
    }
	for (int i = 0 ; i < V ; i++)
	{ 
		for (int j = 0 ; j < V ; j++)
		{ 
			if (i == j) 
				graph[i][j] = 0; 
			else 
				graph[i][j] = INF;	
		}
	}
	for (int i = 0 ; i < E ; i++)
	{
		cin >>source;
		cin >>destn;
		cin >>value;
		graph[source][destn] = value;
		graph[destn][source] = value;		
	}
	cout << "Original matrix" <<endl;
	for (int i = 0 ; i < V ; i++)
	{ 
		for (int j = 0 ; j < V ; j++)
		{ 
			if (graph[i][j] == INF) 
				cout << "INF  ";	 
			else
				cout << graph[i][j] << " ";		
		}
		cout << endl;
	}
	Floyd(graph);
}

//20.Prim's Algorithm
#include<iostream>
using namespace std;
#define INFINITY 9999
int main()
{
	int x,y,u,v,n,i,j,num_edge=1;
	int visited[10]={0},min;
	cin>>n;
	int adj[n][n];
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			cin>>adj[i][j];
			if(adj[i][j]==0)
				adj[i][j]=INFINITY;
		}
	}
	visited[0]=1;
	while(num_edge<n)
	{
		for(i=0,min=INFINITY;i<n;i++)
		{
			for(j=0;j<n;j++)
			{
				if(adj[i][j]<min)
				{
					if(visited[i]!=0)
					{
						min=adj[i][j];
						x=u=i;
						y=v=j;
					}
				}
			}
		}
		if(visited[u]==0 || visited[v]==0)
		{
			cout<<x<<"  "<<y<<"  "<<min<<endl;
			visited[y]=1;
		}
		adj[x][y]=adj[y][x]=9999;
		num_edge++;
	}
}

//21. Dijkstra's algorithm
#include <iostream>
#include <climits>
using namespace std;
#define max 5 
int minDistance (int dist[] , bool sptSet[])
{
    int min = INT_MAX, min_index;

    for (int v = 0; v < max; v++) 
    {
        if (not sptSet[v] && dist[v] <= min)
        {
            min = dist[v];
            min_index = v;
        }
    }

    return min_index;
}

void printSolution (int dist[])
{
    cout << "Vertex\tDistance from Source\n";
    for (int i = 0; i < max; i++)
    {
        cout << i << "\t" << dist[i] << std::endl;
    }
}

void dijkstra (int graph[max][max] , int src) 
{
    int dist[max];
    bool sptSet[max];

    for (int i = 0; i < max; i++) 
    {
        dist[i] = INT_MAX;
        sptSet[i] = false;
    }

    dist[src] = 0;

    for (int count = 0; count < max - 1; count++) 
    {
        int u = minDistance(dist, sptSet);
        sptSet[u] = true;

        for (int v = 0; v < max; v++)
        {
            if (!sptSet[v] && graph[u][v] && dist[u] != INT_MAX && dist[u] + graph[u][v] < dist[v])
            {
                dist[v] = dist[u] + graph[u][v];
            }
        }
    }

    printSolution(dist);
}

int main()
{
    int graph[max][max];
    for (int i = 0 ; i < max ; i++)
    {
        for (int j = 0 ; j < max ; j++)
        {
            cin >> graph[i][j];
        }
    }
    int s;
    cin >> s;
    dijkstra (graph , s);

}

//22. Kruskal's Algorithm
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;
struct Edge
{
    int src, dest, weight;
};

class Graph
{
public:
    int V, E;
    vector<Edge> edges;

    Graph(int V, int E) 
    {
        this->V = V;
        this->E = E;
    }

    void addEdge(int src, int dest, int weight) 
    {
        Edge edge;
        edge.src = src;
        edge.dest = dest;
        edge.weight = weight;
        edges.push_back(edge);
    }

    int findParent(int vertex, vector<int>& parent)
    {
        if (parent[vertex] == -1)
            return vertex;
        return findParent(parent[vertex], parent);
    }

    void unionSets(int x, int y, vector<int>& parent)
    {
        int xset = findParent(x, parent);
        int yset = findParent(y, parent);
        parent[xset] = yset;
    }

    void kruskalMST() 
    {
        vector<Edge> result;
        int i = 0;
        int e = 0;

        sort(edges.begin(), edges.end(), [](const Edge& a, const Edge& b)
        {
            return a.weight < b.weight;
        });

        vector<int> parent(V, -1);

        while (e < V - 1 && i < E)
        {
            Edge nextEdge = edges[i++];
            int x = findParent(nextEdge.src, parent);
            int y = findParent(nextEdge.dest, parent);

            if (x != y) 
            {
                result.push_back(nextEdge);
                unionSets(x, y, parent);
                e++;
            }
        }

        cout << "Following are the edges in the constructed MST" << endl;
        int minimumCost = 0;
        for (i = 0; i < e; i++)
        {
            cout << result[i].src << " -- " << result[i].dest << " == " << result[i].weight << endl;
            minimumCost += result[i].weight;
        }

        cout << "Minimum Cost Spanning Tree: " << minimumCost << endl;
    }
};

int main() 
{
    int V, E;
    cin >> V >> E;
    Graph graph(V, E);

    for (int i = 0; i < E; i++) 
    {
        int src, dest, weight;
        cin >> src >> dest >> weight;
        graph.addEdge(src, dest, weight);
    }

    graph.kruskalMST();
}
